"""
Sionna Scene Builder for HY-Motion Integration
 
This module provides utilities for building Sionna ray tracing scenes
with HY-Motion generated human meshes.
 
Supports:
- Indoor scenes (rooms, corridors)
- Outdoor scenes (streets, open areas)
- Custom scene configuration
- Dynamic human placement based on motion data
"""
 
import os
import tempfile
from dataclasses import dataclass, field
from typing import Dict, List, Optional, Tuple, Any, Union
 
import numpy as np
 
# Check for Sionna availability
try:
    import tensorflow as tf
    tf.config.set_visible_devices([], 'GPU')
 
    import sionna
    from sionna.rt import Scene, Transmitter, Receiver, PlanarArray
    SIONNA_AVAILABLE = True
except ImportError:
    SIONNA_AVAILABLE = False
 
 
@dataclass
class MaterialProperties:
    """RF material properties for ray tracing."""
 
    name: str
    relative_permittivity: float  # epsilon_r
    conductivity: float  # sigma (S/m)
    scattering_coefficient: float = 0.3
    xpd_coefficient: float = 0.0
 
    @classmethod
    def concrete(cls) -> "MaterialProperties":
        """Concrete material (walls, floors)."""
        return cls(
            name="concrete",
            relative_permittivity=5.31,
            conductivity=0.0326,
            scattering_coefficient=0.3,
        )
 
    @classmethod
    def glass(cls) -> "MaterialProperties":
        """Glass material (windows)."""
        return cls(
            name="glass",
            relative_permittivity=6.27,
            conductivity=0.0043,
            scattering_coefficient=0.1,
        )
 
    @classmethod
    def wood(cls) -> "MaterialProperties":
        """Wood material (furniture, doors)."""
        return cls(
            name="wood",
            relative_permittivity=1.99,
            conductivity=0.0047,
            scattering_coefficient=0.4,
        )
 
    @classmethod
    def human_body(cls, frequency: float = 3.5e9) -> "MaterialProperties":
        """
        Human body tissue (frequency-dependent).
 
        Approximation based on skin/muscle tissue at given frequency.
        """
        # Simplified model: values vary with frequency
        if frequency < 1e9:
            eps_r, sigma = 60.0, 0.8
        elif frequency < 6e9:
            eps_r, sigma = 53.0, 1.5
        else:
            eps_r, sigma = 45.0, 3.0
 
        return cls(
            name="human_body",
            relative_permittivity=eps_r,
            conductivity=sigma,
            scattering_coefficient=0.5,
        )
 
    @classmethod
    def metal(cls) -> "MaterialProperties":
        """Metal material (highly reflective)."""
        return cls(
            name="metal",
            relative_permittivity=1.0,
            conductivity=1e7,  # Very high conductivity
            scattering_coefficient=0.0,
        )
 
    @classmethod
    def plasterboard(cls) -> "MaterialProperties":
        """Plasterboard/drywall material."""
        return cls(
            name="plasterboard",
            relative_permittivity=2.94,
            conductivity=0.0116,
            scattering_coefficient=0.3,
        )
 
 
@dataclass
class SceneObject:
    """Represents an object in the scene."""
 
    name: str
    mesh_path: Optional[str] = None  # Path to OBJ/PLY file
    vertices: Optional[np.ndarray] = None  # Direct vertex data
    faces: Optional[np.ndarray] = None  # Direct face data
    position: List[float] = field(default_factory=lambda: [0.0, 0.0, 0.0])
    rotation: List[float] = field(default_factory=lambda: [0.0, 0.0, 0.0])  # Euler angles
    scale: float = 1.0
    material: MaterialProperties = field(default_factory=MaterialProperties.concrete)
    is_dynamic: bool = False  # True for moving objects (humans)
 
 
@dataclass
class TransceiverConfig:
    """Configuration for a transmitter or receiver."""
 
    name: str
    position: List[float]
    orientation: List[float] = field(default_factory=lambda: [0.0, 0.0, 0.0])
    antenna_pattern: str = "iso"  # "iso", "dipole", "hw_dipole", "tr38901"
    num_rows: int = 1
    num_cols: int = 1
    vertical_spacing: float = 0.5
    horizontal_spacing: float = 0.5
    polarization: str = "V"  # "V", "H", "cross"
 
 
class SionnaSceneBuilder:
    """
    Builder class for creating Sionna ray tracing scenes.
 
    Supports adding static environment objects and dynamic human meshes
    generated by HY-Motion.
    """
 
    def __init__(self, frequency: float = 3.5e9):
        """
        Initialize the scene builder.
 
        Args:
            frequency: Carrier frequency in Hz
        """
        self.frequency = frequency
        self.objects: List[SceneObject] = []
        self.transmitters: List[TransceiverConfig] = []
        self.receivers: List[TransceiverConfig] = []
        self.temp_dir = tempfile.mkdtemp(prefix="sionna_scene_")
 
    def add_object(self, obj: SceneObject) -> "SionnaSceneBuilder":
        """Add an object to the scene."""
        self.objects.append(obj)
        return self
 
    def add_transmitter(self, config: TransceiverConfig) -> "SionnaSceneBuilder":
        """Add a transmitter to the scene."""
        self.transmitters.append(config)
        return self
 
    def add_receiver(self, config: TransceiverConfig) -> "SionnaSceneBuilder":
        """Add a receiver to the scene."""
        self.receivers.append(config)
        return self
 
    def add_human_mesh(
        self,
        name: str,
        vertices: np.ndarray,
        faces: np.ndarray,
        position: List[float] = None,
        rotation: List[float] = None,
    ) -> "SionnaSceneBuilder":
        """
        Add a human mesh from HY-Motion to the scene.
 
        Args:
            name: Unique name for this human
            vertices: Mesh vertices (V, 3)
            faces: Mesh faces (F, 3)
            position: World position [x, y, z]
            rotation: Rotation in Euler angles [rx, ry, rz]
        """
        material = MaterialProperties.human_body(self.frequency)
 
        obj = SceneObject(
            name=name,
            vertices=vertices,
            faces=faces,
            position=position or [0.0, 0.0, 0.0],
            rotation=rotation or [0.0, 0.0, 0.0],
            material=material,
            is_dynamic=True,
        )
        self.objects.append(obj)
        return self
 
    def add_room(
        self,
        width: float = 10.0,
        depth: float = 10.0,
        height: float = 3.0,
        wall_material: MaterialProperties = None,
        floor_material: MaterialProperties = None,
        ceiling_material: MaterialProperties = None,
        center: List[float] = None,
    ) -> "SionnaSceneBuilder":
        """
        Add a rectangular room to the scene.
 
        Args:
            width: Room width (X direction)
            depth: Room depth (Y direction)
            height: Room height (Z direction)
            wall_material: Material for walls
            floor_material: Material for floor
            ceiling_material: Material for ceiling
            center: Room center position [x, y, z]
        """
        wall_mat = wall_material or MaterialProperties.concrete()
        floor_mat = floor_material or MaterialProperties.concrete()
        ceiling_mat = ceiling_material or MaterialProperties.plasterboard()
        center = center or [0.0, 0.0, height / 2]
 
        cx, cy, cz = center
        hw, hd, hh = width / 2, depth / 2, height / 2
 
        # Floor
        floor_verts, floor_faces = self._create_plane(
            width, depth,
            position=[cx, cy, cz - hh],
            normal=[0, 0, 1],
        )
        self.add_object(SceneObject(
            name="floor",
            vertices=floor_verts,
            faces=floor_faces,
            material=floor_mat,
        ))
 
        # Ceiling
        ceiling_verts, ceiling_faces = self._create_plane(
            width, depth,
            position=[cx, cy, cz + hh],
            normal=[0, 0, -1],
        )
        self.add_object(SceneObject(
            name="ceiling",
            vertices=ceiling_verts,
            faces=ceiling_faces,
            material=ceiling_mat,
        ))
 
        # Walls
        wall_configs = [
            ("wall_front", [cx, cy + hd, cz], [0, -1, 0], width, height),
            ("wall_back", [cx, cy - hd, cz], [0, 1, 0], width, height),
            ("wall_left", [cx - hw, cy, cz], [1, 0, 0], depth, height),
            ("wall_right", [cx + hw, cy, cz], [-1, 0, 0], depth, height),
        ]
 
        for name, pos, normal, w, h in wall_configs:
            verts, faces = self._create_plane(w, h, position=pos, normal=normal)
            self.add_object(SceneObject(
                name=name,
                vertices=verts,
                faces=faces,
                material=wall_mat,
            ))
 
        return self
 
    def add_corridor(
        self,
        length: float = 20.0,
        width: float = 2.0,
        height: float = 3.0,
        direction: str = "y",  # "x" or "y"
    ) -> "SionnaSceneBuilder":
        """Add a corridor to the scene."""
        if direction == "y":
            return self.add_room(width=width, depth=length, height=height)
        else:
            return self.add_room(width=length, depth=width, height=height)
 
    def add_ground_plane(
        self,
        size: float = 100.0,
        material: MaterialProperties = None,
    ) -> "SionnaSceneBuilder":
        """Add a ground plane for outdoor scenes."""
        mat = material or MaterialProperties.concrete()
        verts, faces = self._create_plane(
            size, size,
            position=[0, 0, 0],
            normal=[0, 0, 1],
        )
        self.add_object(SceneObject(
            name="ground",
            vertices=verts,
            faces=faces,
            material=mat,
        ))
        return self
 
    def add_building(
        self,
        width: float = 10.0,
        depth: float = 10.0,
        height: float = 20.0,
        position: List[float] = None,
        material: MaterialProperties = None,
    ) -> "SionnaSceneBuilder":
        """Add a simple box-shaped building."""
        pos = position or [0.0, 0.0, 0.0]
        mat = material or MaterialProperties.concrete()
 
        verts, faces = self._create_box(width, depth, height, center=pos)
        self.add_object(SceneObject(
            name=f"building_{len(self.objects)}",
            vertices=verts,
            faces=faces,
            position=pos,
            material=mat,
        ))
        return self
 
    def _create_plane(
        self,
        width: float,
        height: float,
        position: List[float],
        normal: List[float],
    ) -> Tuple[np.ndarray, np.ndarray]:
        """Create a plane mesh."""
        hw, hh = width / 2, height / 2
        pos = np.array(position)
        normal = np.array(normal, dtype=float)
        normal = normal / (np.linalg.norm(normal) + 1e-8)
 
        # Create two orthogonal vectors in the plane
        if abs(normal[2]) < 0.9:
            up = np.array([0, 0, 1])
        else:
            up = np.array([0, 1, 0])
 
        right = np.cross(up, normal)
        right = right / (np.linalg.norm(right) + 1e-8)
        up = np.cross(normal, right)
 
        # Four corners
        vertices = np.array([
            pos - hw * right - hh * up,
            pos + hw * right - hh * up,
            pos + hw * right + hh * up,
            pos - hw * right + hh * up,
        ])
 
        # Two triangles
        faces = np.array([
            [0, 1, 2],
            [0, 2, 3],
        ])
 
        return vertices, faces
 
    def _create_box(
        self,
        width: float,
        depth: float,
        height: float,
        center: List[float],
    ) -> Tuple[np.ndarray, np.ndarray]:
        """Create a box mesh."""
        cx, cy, cz = center
        hw, hd, hh = width / 2, depth / 2, height / 2
 
        # 8 vertices of the box
        vertices = np.array([
            [cx - hw, cy - hd, cz],          # 0: bottom back left
            [cx + hw, cy - hd, cz],          # 1: bottom back right
            [cx + hw, cy + hd, cz],          # 2: bottom front right
            [cx - hw, cy + hd, cz],          # 3: bottom front left
            [cx - hw, cy - hd, cz + height], # 4: top back left
            [cx + hw, cy - hd, cz + height], # 5: top back right
            [cx + hw, cy + hd, cz + height], # 6: top front right
            [cx - hw, cy + hd, cz + height], # 7: top front left
        ])
 
        # 12 triangles (2 per face)
        faces = np.array([
            # Bottom
            [0, 2, 1], [0, 3, 2],
            # Top
            [4, 5, 6], [4, 6, 7],
            # Front
            [3, 6, 2], [3, 7, 6],
            # Back
            [0, 1, 5], [0, 5, 4],
            # Left
            [0, 4, 7], [0, 7, 3],
            # Right
            [1, 2, 6], [1, 6, 5],
        ])
 
        return vertices, faces
 
    def build(self) -> Union["Scene", Dict[str, Any]]:
        """
        Build and return the Sionna scene.
 
        Returns:
            Sionna Scene object if available, otherwise a dictionary
            representation of the scene.
        """
        if not SIONNA_AVAILABLE:
            return self._build_fallback()
 
        return self._build_sionna_scene()
 
    def _build_sionna_scene(self) -> "Scene":
        """Build actual Sionna scene."""
        scene = Scene()
        scene.frequency = self.frequency
 
        # Export all meshes to OBJ files and load into scene
        for obj in self.objects:
            mesh_path = self._export_object_mesh(obj)
            # In actual Sionna, you would load the mesh here
            # scene.load_mesh(mesh_path, material=obj.material.name)
 
        # Add transmitters
        for tx_config in self.transmitters:
            tx = Transmitter(
                name=tx_config.name,
                position=tx_config.position,
            )
            scene.add(tx)
 
        # Add receivers
        for rx_config in self.receivers:
            rx = Receiver(
                name=rx_config.name,
                position=rx_config.position,
            )
            scene.add(rx)
 
        # Configure antenna arrays
        if self.transmitters:
            tx_cfg = self.transmitters[0]
            scene.tx_array = PlanarArray(
                num_rows=tx_cfg.num_rows,
                num_cols=tx_cfg.num_cols,
                vertical_spacing=tx_cfg.vertical_spacing,
                horizontal_spacing=tx_cfg.horizontal_spacing,
                pattern=tx_cfg.antenna_pattern,
            )
 
        if self.receivers:
            rx_cfg = self.receivers[0]
            scene.rx_array = PlanarArray(
                num_rows=rx_cfg.num_rows,
                num_cols=rx_cfg.num_cols,
                vertical_spacing=rx_cfg.vertical_spacing,
                horizontal_spacing=rx_cfg.horizontal_spacing,
                pattern=rx_cfg.antenna_pattern,
            )
 
        return scene
 
    def _build_fallback(self) -> Dict[str, Any]:
        """Build a dictionary representation when Sionna is not available."""
        scene_data = {
            "frequency": self.frequency,
            "objects": [],
            "transmitters": [],
            "receivers": [],
        }
 
        for obj in self.objects:
            obj_data = {
                "name": obj.name,
                "position": obj.position,
                "rotation": obj.rotation,
                "scale": obj.scale,
                "material": {
                    "name": obj.material.name,
                    "permittivity": obj.material.relative_permittivity,
                    "conductivity": obj.material.conductivity,
                },
                "is_dynamic": obj.is_dynamic,
            }
            if obj.vertices is not None:
                obj_data["vertices"] = obj.vertices.tolist()
                obj_data["faces"] = obj.faces.tolist()
            scene_data["objects"].append(obj_data)
 
        for tx in self.transmitters:
            scene_data["transmitters"].append({
                "name": tx.name,
                "position": tx.position,
                "orientation": tx.orientation,
                "antenna_pattern": tx.antenna_pattern,
                "array_size": [tx.num_rows, tx.num_cols],
            })
 
        for rx in self.receivers:
            scene_data["receivers"].append({
                "name": rx.name,
                "position": rx.position,
                "orientation": rx.orientation,
                "antenna_pattern": rx.antenna_pattern,
                "array_size": [rx.num_rows, rx.num_cols],
            })
 
        return scene_data
 
    def _export_object_mesh(self, obj: SceneObject) -> str:
        """Export object mesh to OBJ file."""
        if obj.mesh_path:
            return obj.mesh_path
 
        if obj.vertices is None or obj.faces is None:
            raise ValueError(f"Object {obj.name} has no mesh data")
 
        obj_path = os.path.join(self.temp_dir, f"{obj.name}.obj")
        mtl_path = os.path.join(self.temp_dir, f"{obj.name}.mtl")
 
        # Write MTL file
        with open(mtl_path, 'w') as f:
            f.write(f"# Material for {obj.name}\n")
            f.write(f"newmtl {obj.material.name}\n")
            f.write(f"# Relative permittivity: {obj.material.relative_permittivity}\n")
            f.write(f"# Conductivity: {obj.material.conductivity}\n")
            f.write("Ka 0.2 0.2 0.2\n")
            f.write("Kd 0.8 0.8 0.8\n")
            f.write("Ks 0.1 0.1 0.1\n")
 
        # Write OBJ file
        with open(obj_path, 'w') as f:
            f.write(f"# {obj.name}\n")
            f.write(f"mtllib {os.path.basename(mtl_path)}\n")
            f.write(f"usemtl {obj.material.name}\n\n")
 
            for v in obj.vertices:
                f.write(f"v {v[0]} {v[1]} {v[2]}\n")
 
            for face in obj.faces:
                f.write(f"f {face[0]+1} {face[1]+1} {face[2]+1}\n")
 
        return obj_path
 
    def export_scene(self, output_dir: str) -> str:
        """
        Export the complete scene to files.
 
        Args:
            output_dir: Output directory
 
        Returns:
            Path to the main scene file
        """
        import json
 
        os.makedirs(output_dir, exist_ok=True)
 
        # Export all object meshes
        mesh_files = []
        for obj in self.objects:
            mesh_path = self._export_object_mesh(obj)
            # Copy to output dir
            import shutil
            dest_path = os.path.join(output_dir, os.path.basename(mesh_path))
            shutil.copy(mesh_path, dest_path)
            mesh_files.append(dest_path)
 
        # Export scene configuration
        scene_config = {
            "frequency": self.frequency,
            "objects": [
                {
                    "name": obj.name,
                    "mesh_file": os.path.basename(mesh_files[i]) if i < len(mesh_files) else None,
                    "position": obj.position,
                    "rotation": obj.rotation,
                    "scale": obj.scale,
                    "material": {
                        "name": obj.material.name,
                        "relative_permittivity": obj.material.relative_permittivity,
                        "conductivity": obj.material.conductivity,
                        "scattering_coefficient": obj.material.scattering_coefficient,
                    },
                    "is_dynamic": obj.is_dynamic,
                }
                for i, obj in enumerate(self.objects)
            ],
            "transmitters": [
                {
                    "name": tx.name,
                    "position": tx.position,
                    "orientation": tx.orientation,
                    "antenna_pattern": tx.antenna_pattern,
                    "num_rows": tx.num_rows,
                    "num_cols": tx.num_cols,
                }
                for tx in self.transmitters
            ],
            "receivers": [
                {
                    "name": rx.name,
                    "position": rx.position,
                    "orientation": rx.orientation,
                    "antenna_pattern": rx.antenna_pattern,
                    "num_rows": rx.num_rows,
                    "num_cols": rx.num_cols,
                }
                for rx in self.receivers
            ],
        }
 
        scene_path = os.path.join(output_dir, "scene_config.json")
        with open(scene_path, 'w') as f:
            json.dump(scene_config, f, indent=2)
 
        return scene_path
 
 
def create_indoor_scene(
    room_width: float = 10.0,
    room_depth: float = 10.0,
    room_height: float = 3.0,
    frequency: float = 3.5e9,
    tx_position: List[float] = None,
    rx_position: List[float] = None,
) -> SionnaSceneBuilder:
    """
    Create a simple indoor scene with a room.
 
    Args:
        room_width: Room width in meters
        room_depth: Room depth in meters
        room_height: Room height in meters
        frequency: Carrier frequency in Hz
        tx_position: Transmitter position [x, y, z]
        rx_position: Receiver position [x, y, z]
 
    Returns:
        Configured SionnaSceneBuilder
    """
    builder = SionnaSceneBuilder(frequency=frequency)
 
    # Add room
    builder.add_room(
        width=room_width,
        depth=room_depth,
        height=room_height,
    )
 
    # Default positions
    if tx_position is None:
        tx_position = [-room_width/2 + 0.5, 0.0, room_height - 0.5]
    if rx_position is None:
        rx_position = [room_width/2 - 0.5, 0.0, 1.5]
 
    # Add transceivers
    builder.add_transmitter(TransceiverConfig(
        name="tx",
        position=tx_position,
        num_rows=2,
        num_cols=2,
    ))
 
    builder.add_receiver(TransceiverConfig(
        name="rx",
        position=rx_position,
        num_rows=2,
        num_cols=2,
    ))
 
    return builder
 
 
def create_outdoor_scene(
    ground_size: float = 100.0,
    num_buildings: int = 4,
    frequency: float = 3.5e9,
    tx_position: List[float] = None,
    rx_position: List[float] = None,
) -> SionnaSceneBuilder:
    """
    Create a simple outdoor scene with ground and buildings.
 
    Args:
        ground_size: Size of the ground plane in meters
        num_buildings: Number of buildings to add
        frequency: Carrier frequency in Hz
        tx_position: Transmitter position [x, y, z]
        rx_position: Receiver position [x, y, z]
 
    Returns:
        Configured SionnaSceneBuilder
    """
    builder = SionnaSceneBuilder(frequency=frequency)
 
    # Add ground plane
    builder.add_ground_plane(size=ground_size)
 
    # Add buildings in a grid
    building_positions = [
        [-20, -20], [20, -20], [-20, 20], [20, 20],
        [0, -30], [0, 30], [-30, 0], [30, 0],
    ]
 
    for i in range(min(num_buildings, len(building_positions))):
        pos = building_positions[i]
        height = np.random.uniform(10, 30)
        builder.add_building(
            width=10.0,
            depth=10.0,
            height=height,
            position=[pos[0], pos[1], 0.0],
        )
 
    # Default positions
    if tx_position is None:
        tx_position = [0.0, 0.0, 25.0]  # On top of a building
    if rx_position is None:
        rx_position = [15.0, 15.0, 1.5]  # Street level
 
    # Add transceivers
    builder.add_transmitter(TransceiverConfig(
        name="base_station",
        position=tx_position,
        num_rows=4,
        num_cols=4,
        antenna_pattern="tr38901",  # 3GPP pattern
    ))
 
    builder.add_receiver(TransceiverConfig(
        name="ue",
        position=rx_position,
        num_rows=1,
        num_cols=1,
    ))
 
    return builder